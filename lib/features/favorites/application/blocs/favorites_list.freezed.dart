// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'favorites_list.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FavoriteGamesListEventTearOff {
  const _$FavoriteGamesListEventTearOff();

  FavoriteGamesListFetchAll fetchAll() {
    return const FavoriteGamesListFetchAll();
  }

  FavoriteGamesListLoadGames loadGames(List<Game> games) {
    return FavoriteGamesListLoadGames(
      games,
    );
  }

  FavoriteGamesListLoadFavorites loadFavorites(List<FavoriteGame> favorites) {
    return FavoriteGamesListLoadFavorites(
      favorites,
    );
  }

  FavoriteGamesListMerge merge() {
    return const FavoriteGamesListMerge();
  }

  FavoriteGamesListFinishMerging finishMerging(
      List<FavoriteGameVM> viewModels) {
    return FavoriteGamesListFinishMerging(
      viewModels,
    );
  }

  FavoriteGamesListAddFavorite addFavorite(int gameId) {
    return FavoriteGamesListAddFavorite(
      gameId,
    );
  }

  FavoriteGamesListRemoveFavorite removeFavorite(int gameId) {
    return FavoriteGamesListRemoveFavorite(
      gameId,
    );
  }

  FavoriteGamesListHasError hasError(Object? error) {
    return FavoriteGamesListHasError(
      error,
    );
  }

  FavoriteGamesListRetry retry() {
    return const FavoriteGamesListRetry();
  }

  FavoriteGamesListRefresh refresh() {
    return const FavoriteGamesListRefresh();
  }
}

/// @nodoc
const $FavoriteGamesListEvent = _$FavoriteGamesListEventTearOff();

/// @nodoc
mixin _$FavoriteGamesListEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListEventCopyWith<$Res> {
  factory $FavoriteGamesListEventCopyWith(FavoriteGamesListEvent value,
          $Res Function(FavoriteGamesListEvent) then) =
      _$FavoriteGamesListEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListEventCopyWith<$Res> {
  _$FavoriteGamesListEventCopyWithImpl(this._value, this._then);

  final FavoriteGamesListEvent _value;
  // ignore: unused_field
  final $Res Function(FavoriteGamesListEvent) _then;
}

/// @nodoc
abstract class $FavoriteGamesListFetchAllCopyWith<$Res> {
  factory $FavoriteGamesListFetchAllCopyWith(FavoriteGamesListFetchAll value,
          $Res Function(FavoriteGamesListFetchAll) then) =
      _$FavoriteGamesListFetchAllCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListFetchAllCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListFetchAllCopyWith<$Res> {
  _$FavoriteGamesListFetchAllCopyWithImpl(FavoriteGamesListFetchAll _value,
      $Res Function(FavoriteGamesListFetchAll) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListFetchAll));

  @override
  FavoriteGamesListFetchAll get _value =>
      super._value as FavoriteGamesListFetchAll;
}

/// @nodoc

class _$FavoriteGamesListFetchAll implements FavoriteGamesListFetchAll {
  const _$FavoriteGamesListFetchAll();

  @override
  String toString() {
    return 'FavoriteGamesListEvent.fetchAll()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListFetchAll);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return fetchAll();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return fetchAll?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (fetchAll != null) {
      return fetchAll();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return fetchAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return fetchAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (fetchAll != null) {
      return fetchAll(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListFetchAll implements FavoriteGamesListEvent {
  const factory FavoriteGamesListFetchAll() = _$FavoriteGamesListFetchAll;
}

/// @nodoc
abstract class $FavoriteGamesListLoadGamesCopyWith<$Res> {
  factory $FavoriteGamesListLoadGamesCopyWith(FavoriteGamesListLoadGames value,
          $Res Function(FavoriteGamesListLoadGames) then) =
      _$FavoriteGamesListLoadGamesCopyWithImpl<$Res>;
  $Res call({List<Game> games});
}

/// @nodoc
class _$FavoriteGamesListLoadGamesCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListLoadGamesCopyWith<$Res> {
  _$FavoriteGamesListLoadGamesCopyWithImpl(FavoriteGamesListLoadGames _value,
      $Res Function(FavoriteGamesListLoadGames) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListLoadGames));

  @override
  FavoriteGamesListLoadGames get _value =>
      super._value as FavoriteGamesListLoadGames;

  @override
  $Res call({
    Object? games = freezed,
  }) {
    return _then(FavoriteGamesListLoadGames(
      games == freezed
          ? _value.games
          : games // ignore: cast_nullable_to_non_nullable
              as List<Game>,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListLoadGames implements FavoriteGamesListLoadGames {
  const _$FavoriteGamesListLoadGames(this.games);

  @override
  final List<Game> games;

  @override
  String toString() {
    return 'FavoriteGamesListEvent.loadGames(games: $games)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListLoadGames &&
            const DeepCollectionEquality().equals(other.games, games));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(games));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListLoadGamesCopyWith<FavoriteGamesListLoadGames>
      get copyWith =>
          _$FavoriteGamesListLoadGamesCopyWithImpl<FavoriteGamesListLoadGames>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return loadGames(games);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return loadGames?.call(games);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (loadGames != null) {
      return loadGames(games);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return loadGames(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return loadGames?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (loadGames != null) {
      return loadGames(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListLoadGames implements FavoriteGamesListEvent {
  const factory FavoriteGamesListLoadGames(List<Game> games) =
      _$FavoriteGamesListLoadGames;

  List<Game> get games;
  @JsonKey(ignore: true)
  $FavoriteGamesListLoadGamesCopyWith<FavoriteGamesListLoadGames>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListLoadFavoritesCopyWith<$Res> {
  factory $FavoriteGamesListLoadFavoritesCopyWith(
          FavoriteGamesListLoadFavorites value,
          $Res Function(FavoriteGamesListLoadFavorites) then) =
      _$FavoriteGamesListLoadFavoritesCopyWithImpl<$Res>;
  $Res call({List<FavoriteGame> favorites});
}

/// @nodoc
class _$FavoriteGamesListLoadFavoritesCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListLoadFavoritesCopyWith<$Res> {
  _$FavoriteGamesListLoadFavoritesCopyWithImpl(
      FavoriteGamesListLoadFavorites _value,
      $Res Function(FavoriteGamesListLoadFavorites) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListLoadFavorites));

  @override
  FavoriteGamesListLoadFavorites get _value =>
      super._value as FavoriteGamesListLoadFavorites;

  @override
  $Res call({
    Object? favorites = freezed,
  }) {
    return _then(FavoriteGamesListLoadFavorites(
      favorites == freezed
          ? _value.favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<FavoriteGame>,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListLoadFavorites
    implements FavoriteGamesListLoadFavorites {
  const _$FavoriteGamesListLoadFavorites(this.favorites);

  @override
  final List<FavoriteGame> favorites;

  @override
  String toString() {
    return 'FavoriteGamesListEvent.loadFavorites(favorites: $favorites)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListLoadFavorites &&
            const DeepCollectionEquality().equals(other.favorites, favorites));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(favorites));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListLoadFavoritesCopyWith<FavoriteGamesListLoadFavorites>
      get copyWith => _$FavoriteGamesListLoadFavoritesCopyWithImpl<
          FavoriteGamesListLoadFavorites>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return loadFavorites(favorites);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return loadFavorites?.call(favorites);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (loadFavorites != null) {
      return loadFavorites(favorites);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return loadFavorites(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return loadFavorites?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (loadFavorites != null) {
      return loadFavorites(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListLoadFavorites
    implements FavoriteGamesListEvent {
  const factory FavoriteGamesListLoadFavorites(List<FavoriteGame> favorites) =
      _$FavoriteGamesListLoadFavorites;

  List<FavoriteGame> get favorites;
  @JsonKey(ignore: true)
  $FavoriteGamesListLoadFavoritesCopyWith<FavoriteGamesListLoadFavorites>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListMergeCopyWith<$Res> {
  factory $FavoriteGamesListMergeCopyWith(FavoriteGamesListMerge value,
          $Res Function(FavoriteGamesListMerge) then) =
      _$FavoriteGamesListMergeCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListMergeCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListMergeCopyWith<$Res> {
  _$FavoriteGamesListMergeCopyWithImpl(FavoriteGamesListMerge _value,
      $Res Function(FavoriteGamesListMerge) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListMerge));

  @override
  FavoriteGamesListMerge get _value => super._value as FavoriteGamesListMerge;
}

/// @nodoc

class _$FavoriteGamesListMerge implements FavoriteGamesListMerge {
  const _$FavoriteGamesListMerge();

  @override
  String toString() {
    return 'FavoriteGamesListEvent.merge()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is FavoriteGamesListMerge);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return merge();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return merge?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (merge != null) {
      return merge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return merge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return merge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (merge != null) {
      return merge(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListMerge implements FavoriteGamesListEvent {
  const factory FavoriteGamesListMerge() = _$FavoriteGamesListMerge;
}

/// @nodoc
abstract class $FavoriteGamesListFinishMergingCopyWith<$Res> {
  factory $FavoriteGamesListFinishMergingCopyWith(
          FavoriteGamesListFinishMerging value,
          $Res Function(FavoriteGamesListFinishMerging) then) =
      _$FavoriteGamesListFinishMergingCopyWithImpl<$Res>;
  $Res call({List<FavoriteGameVM> viewModels});
}

/// @nodoc
class _$FavoriteGamesListFinishMergingCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListFinishMergingCopyWith<$Res> {
  _$FavoriteGamesListFinishMergingCopyWithImpl(
      FavoriteGamesListFinishMerging _value,
      $Res Function(FavoriteGamesListFinishMerging) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListFinishMerging));

  @override
  FavoriteGamesListFinishMerging get _value =>
      super._value as FavoriteGamesListFinishMerging;

  @override
  $Res call({
    Object? viewModels = freezed,
  }) {
    return _then(FavoriteGamesListFinishMerging(
      viewModels == freezed
          ? _value.viewModels
          : viewModels // ignore: cast_nullable_to_non_nullable
              as List<FavoriteGameVM>,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListFinishMerging
    implements FavoriteGamesListFinishMerging {
  const _$FavoriteGamesListFinishMerging(this.viewModels);

  @override
  final List<FavoriteGameVM> viewModels;

  @override
  String toString() {
    return 'FavoriteGamesListEvent.finishMerging(viewModels: $viewModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListFinishMerging &&
            const DeepCollectionEquality()
                .equals(other.viewModels, viewModels));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(viewModels));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListFinishMergingCopyWith<FavoriteGamesListFinishMerging>
      get copyWith => _$FavoriteGamesListFinishMergingCopyWithImpl<
          FavoriteGamesListFinishMerging>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return finishMerging(viewModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return finishMerging?.call(viewModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (finishMerging != null) {
      return finishMerging(viewModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return finishMerging(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return finishMerging?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (finishMerging != null) {
      return finishMerging(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListFinishMerging
    implements FavoriteGamesListEvent {
  const factory FavoriteGamesListFinishMerging(
      List<FavoriteGameVM> viewModels) = _$FavoriteGamesListFinishMerging;

  List<FavoriteGameVM> get viewModels;
  @JsonKey(ignore: true)
  $FavoriteGamesListFinishMergingCopyWith<FavoriteGamesListFinishMerging>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListAddFavoriteCopyWith<$Res> {
  factory $FavoriteGamesListAddFavoriteCopyWith(
          FavoriteGamesListAddFavorite value,
          $Res Function(FavoriteGamesListAddFavorite) then) =
      _$FavoriteGamesListAddFavoriteCopyWithImpl<$Res>;
  $Res call({int gameId});
}

/// @nodoc
class _$FavoriteGamesListAddFavoriteCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListAddFavoriteCopyWith<$Res> {
  _$FavoriteGamesListAddFavoriteCopyWithImpl(
      FavoriteGamesListAddFavorite _value,
      $Res Function(FavoriteGamesListAddFavorite) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListAddFavorite));

  @override
  FavoriteGamesListAddFavorite get _value =>
      super._value as FavoriteGamesListAddFavorite;

  @override
  $Res call({
    Object? gameId = freezed,
  }) {
    return _then(FavoriteGamesListAddFavorite(
      gameId == freezed
          ? _value.gameId
          : gameId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListAddFavorite implements FavoriteGamesListAddFavorite {
  const _$FavoriteGamesListAddFavorite(this.gameId);

  @override
  final int gameId;

  @override
  String toString() {
    return 'FavoriteGamesListEvent.addFavorite(gameId: $gameId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListAddFavorite &&
            const DeepCollectionEquality().equals(other.gameId, gameId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(gameId));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListAddFavoriteCopyWith<FavoriteGamesListAddFavorite>
      get copyWith => _$FavoriteGamesListAddFavoriteCopyWithImpl<
          FavoriteGamesListAddFavorite>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return addFavorite(gameId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return addFavorite?.call(gameId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (addFavorite != null) {
      return addFavorite(gameId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return addFavorite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return addFavorite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (addFavorite != null) {
      return addFavorite(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListAddFavorite implements FavoriteGamesListEvent {
  const factory FavoriteGamesListAddFavorite(int gameId) =
      _$FavoriteGamesListAddFavorite;

  int get gameId;
  @JsonKey(ignore: true)
  $FavoriteGamesListAddFavoriteCopyWith<FavoriteGamesListAddFavorite>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListRemoveFavoriteCopyWith<$Res> {
  factory $FavoriteGamesListRemoveFavoriteCopyWith(
          FavoriteGamesListRemoveFavorite value,
          $Res Function(FavoriteGamesListRemoveFavorite) then) =
      _$FavoriteGamesListRemoveFavoriteCopyWithImpl<$Res>;
  $Res call({int gameId});
}

/// @nodoc
class _$FavoriteGamesListRemoveFavoriteCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListRemoveFavoriteCopyWith<$Res> {
  _$FavoriteGamesListRemoveFavoriteCopyWithImpl(
      FavoriteGamesListRemoveFavorite _value,
      $Res Function(FavoriteGamesListRemoveFavorite) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListRemoveFavorite));

  @override
  FavoriteGamesListRemoveFavorite get _value =>
      super._value as FavoriteGamesListRemoveFavorite;

  @override
  $Res call({
    Object? gameId = freezed,
  }) {
    return _then(FavoriteGamesListRemoveFavorite(
      gameId == freezed
          ? _value.gameId
          : gameId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListRemoveFavorite
    implements FavoriteGamesListRemoveFavorite {
  const _$FavoriteGamesListRemoveFavorite(this.gameId);

  @override
  final int gameId;

  @override
  String toString() {
    return 'FavoriteGamesListEvent.removeFavorite(gameId: $gameId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListRemoveFavorite &&
            const DeepCollectionEquality().equals(other.gameId, gameId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(gameId));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListRemoveFavoriteCopyWith<FavoriteGamesListRemoveFavorite>
      get copyWith => _$FavoriteGamesListRemoveFavoriteCopyWithImpl<
          FavoriteGamesListRemoveFavorite>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return removeFavorite(gameId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return removeFavorite?.call(gameId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (removeFavorite != null) {
      return removeFavorite(gameId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return removeFavorite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return removeFavorite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (removeFavorite != null) {
      return removeFavorite(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListRemoveFavorite
    implements FavoriteGamesListEvent {
  const factory FavoriteGamesListRemoveFavorite(int gameId) =
      _$FavoriteGamesListRemoveFavorite;

  int get gameId;
  @JsonKey(ignore: true)
  $FavoriteGamesListRemoveFavoriteCopyWith<FavoriteGamesListRemoveFavorite>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListHasErrorCopyWith<$Res> {
  factory $FavoriteGamesListHasErrorCopyWith(FavoriteGamesListHasError value,
          $Res Function(FavoriteGamesListHasError) then) =
      _$FavoriteGamesListHasErrorCopyWithImpl<$Res>;
  $Res call({Object? error});
}

/// @nodoc
class _$FavoriteGamesListHasErrorCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListHasErrorCopyWith<$Res> {
  _$FavoriteGamesListHasErrorCopyWithImpl(FavoriteGamesListHasError _value,
      $Res Function(FavoriteGamesListHasError) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListHasError));

  @override
  FavoriteGamesListHasError get _value =>
      super._value as FavoriteGamesListHasError;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(FavoriteGamesListHasError(
      error == freezed ? _value.error : error,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListHasError implements FavoriteGamesListHasError {
  const _$FavoriteGamesListHasError(this.error);

  @override
  final Object? error;

  @override
  String toString() {
    return 'FavoriteGamesListEvent.hasError(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListHasError &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListHasErrorCopyWith<FavoriteGamesListHasError> get copyWith =>
      _$FavoriteGamesListHasErrorCopyWithImpl<FavoriteGamesListHasError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return hasError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return hasError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (hasError != null) {
      return hasError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return hasError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return hasError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (hasError != null) {
      return hasError(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListHasError implements FavoriteGamesListEvent {
  const factory FavoriteGamesListHasError(Object? error) =
      _$FavoriteGamesListHasError;

  Object? get error;
  @JsonKey(ignore: true)
  $FavoriteGamesListHasErrorCopyWith<FavoriteGamesListHasError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListRetryCopyWith<$Res> {
  factory $FavoriteGamesListRetryCopyWith(FavoriteGamesListRetry value,
          $Res Function(FavoriteGamesListRetry) then) =
      _$FavoriteGamesListRetryCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListRetryCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListRetryCopyWith<$Res> {
  _$FavoriteGamesListRetryCopyWithImpl(FavoriteGamesListRetry _value,
      $Res Function(FavoriteGamesListRetry) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListRetry));

  @override
  FavoriteGamesListRetry get _value => super._value as FavoriteGamesListRetry;
}

/// @nodoc

class _$FavoriteGamesListRetry implements FavoriteGamesListRetry {
  const _$FavoriteGamesListRetry();

  @override
  String toString() {
    return 'FavoriteGamesListEvent.retry()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is FavoriteGamesListRetry);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return retry();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return retry?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (retry != null) {
      return retry();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return retry(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return retry?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (retry != null) {
      return retry(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListRetry implements FavoriteGamesListEvent {
  const factory FavoriteGamesListRetry() = _$FavoriteGamesListRetry;
}

/// @nodoc
abstract class $FavoriteGamesListRefreshCopyWith<$Res> {
  factory $FavoriteGamesListRefreshCopyWith(FavoriteGamesListRefresh value,
          $Res Function(FavoriteGamesListRefresh) then) =
      _$FavoriteGamesListRefreshCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListRefreshCopyWithImpl<$Res>
    extends _$FavoriteGamesListEventCopyWithImpl<$Res>
    implements $FavoriteGamesListRefreshCopyWith<$Res> {
  _$FavoriteGamesListRefreshCopyWithImpl(FavoriteGamesListRefresh _value,
      $Res Function(FavoriteGamesListRefresh) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListRefresh));

  @override
  FavoriteGamesListRefresh get _value =>
      super._value as FavoriteGamesListRefresh;
}

/// @nodoc

class _$FavoriteGamesListRefresh implements FavoriteGamesListRefresh {
  const _$FavoriteGamesListRefresh();

  @override
  String toString() {
    return 'FavoriteGamesListEvent.refresh()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is FavoriteGamesListRefresh);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchAll,
    required TResult Function(List<Game> games) loadGames,
    required TResult Function(List<FavoriteGame> favorites) loadFavorites,
    required TResult Function() merge,
    required TResult Function(List<FavoriteGameVM> viewModels) finishMerging,
    required TResult Function(int gameId) addFavorite,
    required TResult Function(int gameId) removeFavorite,
    required TResult Function(Object? error) hasError,
    required TResult Function() retry,
    required TResult Function() refresh,
  }) {
    return refresh();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
  }) {
    return refresh?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchAll,
    TResult Function(List<Game> games)? loadGames,
    TResult Function(List<FavoriteGame> favorites)? loadFavorites,
    TResult Function()? merge,
    TResult Function(List<FavoriteGameVM> viewModels)? finishMerging,
    TResult Function(int gameId)? addFavorite,
    TResult Function(int gameId)? removeFavorite,
    TResult Function(Object? error)? hasError,
    TResult Function()? retry,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListFetchAll value) fetchAll,
    required TResult Function(FavoriteGamesListLoadGames value) loadGames,
    required TResult Function(FavoriteGamesListLoadFavorites value)
        loadFavorites,
    required TResult Function(FavoriteGamesListMerge value) merge,
    required TResult Function(FavoriteGamesListFinishMerging value)
        finishMerging,
    required TResult Function(FavoriteGamesListAddFavorite value) addFavorite,
    required TResult Function(FavoriteGamesListRemoveFavorite value)
        removeFavorite,
    required TResult Function(FavoriteGamesListHasError value) hasError,
    required TResult Function(FavoriteGamesListRetry value) retry,
    required TResult Function(FavoriteGamesListRefresh value) refresh,
  }) {
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
  }) {
    return refresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListFetchAll value)? fetchAll,
    TResult Function(FavoriteGamesListLoadGames value)? loadGames,
    TResult Function(FavoriteGamesListLoadFavorites value)? loadFavorites,
    TResult Function(FavoriteGamesListMerge value)? merge,
    TResult Function(FavoriteGamesListFinishMerging value)? finishMerging,
    TResult Function(FavoriteGamesListAddFavorite value)? addFavorite,
    TResult Function(FavoriteGamesListRemoveFavorite value)? removeFavorite,
    TResult Function(FavoriteGamesListHasError value)? hasError,
    TResult Function(FavoriteGamesListRetry value)? retry,
    TResult Function(FavoriteGamesListRefresh value)? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListRefresh implements FavoriteGamesListEvent {
  const factory FavoriteGamesListRefresh() = _$FavoriteGamesListRefresh;
}

/// @nodoc
class _$FavoriteGamesListStateTearOff {
  const _$FavoriteGamesListStateTearOff();

  FavoriteGamesListLoading loading() {
    return const FavoriteGamesListLoading();
  }

  FavoriteGamesListLoaded loaded(List<FavoriteGame> favorites, List<Game> games,
      [List<FavoriteGameVM> viewModels = const []]) {
    return FavoriteGamesListLoaded(
      favorites,
      games,
      viewModels,
    );
  }

  FavoriteGamesListError error(String message) {
    return FavoriteGamesListError(
      message,
    );
  }
}

/// @nodoc
const $FavoriteGamesListState = _$FavoriteGamesListStateTearOff();

/// @nodoc
mixin _$FavoriteGamesListState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)
        loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListLoading value) loading,
    required TResult Function(FavoriteGamesListLoaded value) loaded,
    required TResult Function(FavoriteGamesListError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListStateCopyWith<$Res> {
  factory $FavoriteGamesListStateCopyWith(FavoriteGamesListState value,
          $Res Function(FavoriteGamesListState) then) =
      _$FavoriteGamesListStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListStateCopyWithImpl<$Res>
    implements $FavoriteGamesListStateCopyWith<$Res> {
  _$FavoriteGamesListStateCopyWithImpl(this._value, this._then);

  final FavoriteGamesListState _value;
  // ignore: unused_field
  final $Res Function(FavoriteGamesListState) _then;
}

/// @nodoc
abstract class $FavoriteGamesListLoadingCopyWith<$Res> {
  factory $FavoriteGamesListLoadingCopyWith(FavoriteGamesListLoading value,
          $Res Function(FavoriteGamesListLoading) then) =
      _$FavoriteGamesListLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$FavoriteGamesListLoadingCopyWithImpl<$Res>
    extends _$FavoriteGamesListStateCopyWithImpl<$Res>
    implements $FavoriteGamesListLoadingCopyWith<$Res> {
  _$FavoriteGamesListLoadingCopyWithImpl(FavoriteGamesListLoading _value,
      $Res Function(FavoriteGamesListLoading) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListLoading));

  @override
  FavoriteGamesListLoading get _value =>
      super._value as FavoriteGamesListLoading;
}

/// @nodoc

class _$FavoriteGamesListLoading implements FavoriteGamesListLoading {
  const _$FavoriteGamesListLoading();

  @override
  String toString() {
    return 'FavoriteGamesListState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is FavoriteGamesListLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListLoading value) loading,
    required TResult Function(FavoriteGamesListLoaded value) loaded,
    required TResult Function(FavoriteGamesListError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListLoading implements FavoriteGamesListState {
  const factory FavoriteGamesListLoading() = _$FavoriteGamesListLoading;
}

/// @nodoc
abstract class $FavoriteGamesListLoadedCopyWith<$Res> {
  factory $FavoriteGamesListLoadedCopyWith(FavoriteGamesListLoaded value,
          $Res Function(FavoriteGamesListLoaded) then) =
      _$FavoriteGamesListLoadedCopyWithImpl<$Res>;
  $Res call(
      {List<FavoriteGame> favorites,
      List<Game> games,
      List<FavoriteGameVM> viewModels});
}

/// @nodoc
class _$FavoriteGamesListLoadedCopyWithImpl<$Res>
    extends _$FavoriteGamesListStateCopyWithImpl<$Res>
    implements $FavoriteGamesListLoadedCopyWith<$Res> {
  _$FavoriteGamesListLoadedCopyWithImpl(FavoriteGamesListLoaded _value,
      $Res Function(FavoriteGamesListLoaded) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListLoaded));

  @override
  FavoriteGamesListLoaded get _value => super._value as FavoriteGamesListLoaded;

  @override
  $Res call({
    Object? favorites = freezed,
    Object? games = freezed,
    Object? viewModels = freezed,
  }) {
    return _then(FavoriteGamesListLoaded(
      favorites == freezed
          ? _value.favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<FavoriteGame>,
      games == freezed
          ? _value.games
          : games // ignore: cast_nullable_to_non_nullable
              as List<Game>,
      viewModels == freezed
          ? _value.viewModels
          : viewModels // ignore: cast_nullable_to_non_nullable
              as List<FavoriteGameVM>,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListLoaded implements FavoriteGamesListLoaded {
  const _$FavoriteGamesListLoaded(this.favorites, this.games,
      [this.viewModels = const []]);

  @override
  final List<FavoriteGame> favorites;
  @override
  final List<Game> games;
  @JsonKey()
  @override
  final List<FavoriteGameVM> viewModels;

  @override
  String toString() {
    return 'FavoriteGamesListState.loaded(favorites: $favorites, games: $games, viewModels: $viewModels)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListLoaded &&
            const DeepCollectionEquality().equals(other.favorites, favorites) &&
            const DeepCollectionEquality().equals(other.games, games) &&
            const DeepCollectionEquality()
                .equals(other.viewModels, viewModels));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(favorites),
      const DeepCollectionEquality().hash(games),
      const DeepCollectionEquality().hash(viewModels));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListLoadedCopyWith<FavoriteGamesListLoaded> get copyWith =>
      _$FavoriteGamesListLoadedCopyWithImpl<FavoriteGamesListLoaded>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(favorites, games, viewModels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
  }) {
    return loaded?.call(favorites, games, viewModels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(favorites, games, viewModels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListLoading value) loading,
    required TResult Function(FavoriteGamesListLoaded value) loaded,
    required TResult Function(FavoriteGamesListError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListLoaded implements FavoriteGamesListState {
  const factory FavoriteGamesListLoaded(
      List<FavoriteGame> favorites, List<Game> games,
      [List<FavoriteGameVM> viewModels]) = _$FavoriteGamesListLoaded;

  List<FavoriteGame> get favorites;
  List<Game> get games;
  List<FavoriteGameVM> get viewModels;
  @JsonKey(ignore: true)
  $FavoriteGamesListLoadedCopyWith<FavoriteGamesListLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FavoriteGamesListErrorCopyWith<$Res> {
  factory $FavoriteGamesListErrorCopyWith(FavoriteGamesListError value,
          $Res Function(FavoriteGamesListError) then) =
      _$FavoriteGamesListErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class _$FavoriteGamesListErrorCopyWithImpl<$Res>
    extends _$FavoriteGamesListStateCopyWithImpl<$Res>
    implements $FavoriteGamesListErrorCopyWith<$Res> {
  _$FavoriteGamesListErrorCopyWithImpl(FavoriteGamesListError _value,
      $Res Function(FavoriteGamesListError) _then)
      : super(_value, (v) => _then(v as FavoriteGamesListError));

  @override
  FavoriteGamesListError get _value => super._value as FavoriteGamesListError;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(FavoriteGamesListError(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FavoriteGamesListError implements FavoriteGamesListError {
  const _$FavoriteGamesListError(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'FavoriteGamesListState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FavoriteGamesListError &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  $FavoriteGamesListErrorCopyWith<FavoriteGamesListError> get copyWith =>
      _$FavoriteGamesListErrorCopyWithImpl<FavoriteGamesListError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)
        loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<FavoriteGame> favorites, List<Game> games,
            List<FavoriteGameVM> viewModels)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FavoriteGamesListLoading value) loading,
    required TResult Function(FavoriteGamesListLoaded value) loaded,
    required TResult Function(FavoriteGamesListError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FavoriteGamesListLoading value)? loading,
    TResult Function(FavoriteGamesListLoaded value)? loaded,
    TResult Function(FavoriteGamesListError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class FavoriteGamesListError implements FavoriteGamesListState {
  const factory FavoriteGamesListError(String message) =
      _$FavoriteGamesListError;

  String get message;
  @JsonKey(ignore: true)
  $FavoriteGamesListErrorCopyWith<FavoriteGamesListError> get copyWith =>
      throw _privateConstructorUsedError;
}
